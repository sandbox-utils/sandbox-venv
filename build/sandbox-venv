#!/bin/sh
# sandbox-venv: container sandbox venv wrapper
# Wraps all .venv/bin entry‑points so they run under bubblewrap.
# Also re‑wrap any new scripts post installation by pip etc.
# shellcheck disable=SC2317
set -eu
# shellcheck disable=SC3040
case "$(set -o)" in *pipefail*) set -o pipefail ;; esac

for arg; do case "$arg" in -h|-\?|--help) echo "Usage: ${0##*/} [VENV_DIR] [BWRAP_OPTS]    # Dir defaults to .venv"; exit ;; esac; done

warn () { echo "sandbox-venv: $*" >&2; }
alias realpath='realpath --no-symlinks'

command -v bwrap >/dev/null || { warn 'Required command bwrap missing; apt install bubblewrap ?' ; exit 1; }

# Filter args s.t. $@ == bwrap extra args
venv='.venv'; [ $# -eq 0 ] || case "$1" in -*) ;; *) venv="$(realpath "$1")"; shift ;; esac

cd "$venv/bin" || { warn 'Error: Missing venv. Make a venv: python -m venv .venv'; exit 1; }
cd "../.."  # I.e. the project dir
venv="${venv##*/}"
bin="$venv/bin"
[ -d "$bin" ] || { warn 'Assertion failed'; exit 2; }
this_script="$(command -v "$0")"
[ -f "$this_script" ] || { warn 'Assertion failed'; exit 3; }

is_python_shebang () {
    shebang_line="$(head -n1 "$1" | tr -d '\0')"
    test "${shebang_line#\#!}" = "$(realpath "${1%/*}/python")"
}
is_already_wrapped () { head -n2 "$1" | grep -q '^# sandbox-venv'; }
export_func () { awk "/^$1 \(\) {/,/^}|; }\$/" "$0"; }
extract_segment () {
    segment="$1"; shift
    awk "/^# CUT HERE / { c++; next } c==$segment" "$this_script" |
        sed -E "s|^_BWRAP_DEFAULT_ARGS=.*|_BWRAP_DEFAULT_ARGS=\"$*\"|"
}

wrap_pip () {
    out="$1"; shift
    extract_segment 1 "$@" > "$out"
    printf '%s\n%s\n%s\n' \
            "$(export_func split_args_by_lf)" \
            "$(export_func is_python_shebang)" \
            "$(export_func is_already_wrapped)" |
        sed -i -E '/^# AUX_FUNCS.*/{
            r /dev/stdin
            d}' "$out"
}

wrap_executable () {
    out="$1" executable="$2"; shift 2
    extract_segment 2 "$@" > "$out"
    sed -i -E "s|^EXECUTABLE=.*|EXECUTABLE='${executable##*/}'|" "$out"
}

add_bin_shell () {
    cat > "$1" <<EOF
#!/bin/env ${1%/*}/python
import shutil
import subprocess
import sys
if __name__ == '__main__':
    shell = shutil.which('/bin/bash') or '/bin/sh'
    sys.exit(subprocess.run([shell, *sys.argv[1:]]).returncode)
EOF
}

wrap_all () (
    rm -f "$bin/../cache/sandbox-venv.cache"
    for file in "$bin"/*; do
        # shellcheck disable=SC2015
        [ -f "$file" ] && [ -x "$file" ] || continue
        [ "${file##*/}" != 'shell' ] || continue  # Skip our bin/shell
        case "${file##*/}" in pip*) ;; *) ! is_python_shebang "$file" || continue ;; esac  # Skip if wrapped transitively, except pip
        # shellcheck disable=SC2015
        [ -L "$file" ] && case "$(readlink "$file")" in /*) ;; *) continue ;; esac || true  # Skip relative symlinks

        unsafe_file="$bin/.unsafe_${file##*/}"
        if [ ! -e "$unsafe_file" ]; then mv -v "$file" "$unsafe_file"; fi

        case "${file##*/}" in
            pip|pip3*) wrap_pip "$file" "$@" ;;
            *) wrap_executable "$file" "$unsafe_file" "$@" ;;
        esac
        chmod +x "$file"
        echo "$file"
    done

    # Install $venv/bin/shell
    file="$bin/shell"
    add_bin_shell "$file"
    chmod +x "$file"
    echo "$file"

    # Install deactivate_sandbox hook in $venv/bin/activate
    grep -Fq deactivate_sandbox "$bin/activate" ||
        cat >> "$bin/activate" <<EOF

deactivate_sandbox () { for f in "$(realpath "$bin")"/.unsafe_*; do mv -vf "\$f" "\${f%/*}/\${f##*/.unsafe_}"; done; }
EOF

    # Install PYTHONPATH=$venv/sandbox with sitecustomize.py
    mkdir -p "$bin/../sandbox"
    extract_segment 3 "$@" > "$bin/../sandbox/sitecustomize.py"
)

wrap_all "$@"
exit 0


# CUT HERE ------------------- Appendix 1: sandbox-venv _wrapper_pip.sh script
#!/bin/sh
# sandbox-venv: Secure container sandbox venv wrapper (GENERATED CODE)
# pip wrapper: Re-run sandbox-venv after every pip installation
set -u
# shellcheck disable=SC3040
case "$(set -o)" in *pipefail*) set -o pipefail ;; esac
alias realpath='realpath --no-symlinks'

venv="$(realpath "${0%/*}/..")"

_BWRAP_DEFAULT_ARGS=

# AUX_FUNCS: Auxiliary functions get inserted here

BWRAP_ARGS="$(split_args_by_lf "$_BWRAP_DEFAULT_ARGS")
--bind
$venv
$venv
$(split_args_by_lf "${BWRAP_ARGS-}")" \
    "$venv/bin/.unsafe_${0##*/}" "$@"
pip_return_status=$?

rm -f "$venv/cache/sandbox-venv.cache"

new_binaries="$(
    for file in "$venv/bin"/*; do
        [ -L "$file" ] || [ -d "$file" ] || [ ! -x "$file" ] ||
            [ "${file##*/}" = 'shell' ] ||
            is_already_wrapped "$file" ||
            is_python_shebang "$file" ||
            printf ' %s' "${file##*/}"
    done)"

if [ "$new_binaries" ]; then
    # Reset shebang to the one outside the sandbox
    for exe in $new_binaries; do sed -i "1s,/bin/.unsafe_,/bin/," "$venv/bin/$exe"; done

    if [ "$(command -v sandbox-venv)" ]; then
        echo "sandbox-venv: New binaries found:$new_binaries. Re-running sandbox-venv ..."
        sandbox-venv "$venv"
    else echo "WARNING: sandbox-venv not in \$PATH. Cannot sandbox/patch new executables:$new_binaries. Rerun sandbox-venv on this venv to stay secure."
    fi
fi

exit $pip_return_status


# CUT HERE ------------------- Appendix 2: sandbox-venv _wrapper_exe.sh script
#!/bin/sh
# sandbox-venv: Secure container sandbox venv wrapper (GENERATED CODE)
set -eu
# shellcheck disable=SC3040
case "$(set -o)" in *pipefail*) set -o pipefail ;; esac
alias realpath='realpath --no-symlinks'
warn () { echo "sandbox-venv/wrapper: $*" >&2; }
command_exists () { command -v "$1" >/dev/null 2>&1; }

venv="$(realpath "${0%/*}/..")"
proj_dir="$(realpath "$venv/..")"

# Quote args with spaces. Do this here before overriding "$@"
format_args () {
    for arg in "$@"; do case "$arg" in
        $venv/*) printf "%s " "${venv##*/}/${arg#"$venv/"}" ;;
        *\ *) printf "'%s' " "$arg" ;;
        *) printf "%s " "$arg" ;;
    esac; done
}
formatted_cmdline="python $(format_args "$@")"

EXECUTABLE="${1:-/usr/bin/python3}"
_BWRAP_DEFAULT_ARGS=

[ -e "$venv/bin/python3" ]  # Assertion

# Expose these binaries
executables="
    /usr/bin/python
    /usr/bin/python3
    /usr/bin/python3*

    /usr/bin*/git
    /usr/bin/git-receive-*
    /usr/bin/git-upload-*

    /bin/bash
    /bin/env
    /bin/ls
    /bin/sh

    /bin/uname
    /sbin/ldconfig*
"
# Explicit Python deps we know of
py_libs="
    /usr/include/python3*
    /usr/lib/python3*
    /usr/lib64/python3*
    /usr/local/lib/python3*
"
seccomp_libs="
    /usr/lib/python3*/*/seccomp.*.so
    /usr/lib/*/libseccomp.so*
    /usr/lib64/libseccomp.so*
"
git_libs="
    /usr/lib*/git-core
"
ro_bind_extra="
    /etc/hosts
    /etc/resolv.conf

    /etc/ld.so.cache
    /etc/os-release
    /usr/share/locale
    /usr/share/zoneinfo
    /etc/localtime
    /etc/timezone

    /usr/share/ca-certificates*
    /etc/pki*
    /etc/ssl
    /usr/share/pki*
"

# Begin constructing args for bwrap, in reverse
# (later args in command line override prior ones)

split_args_by_lf () {
    lf='
'
    printf '%s' "$1" | case "$1" in *$lf*) cat ;; *) tr ' ' '\n' ;; esac
}

# Support BWRAP_ARGS passed to the process as well as via .env file
prev_BWRAP_ARGS="${BWRAP_ARGS:-}"
# Init env from dotenv file
# shellcheck disable=SC2046
[ ! -e "$proj_dir/.env" ] || { . "$proj_dir/.env"; export $(grep -Pzo '(?m)^\w*(?==)' "$proj_dir/.env" | tr '\0' '\n'); }
IFS='
'  # Split args only on newline
_USER_ARGS="$(split_args_by_lf "$_BWRAP_DEFAULT_ARGS")
$(split_args_by_lf "${prev_BWRAP_ARGS:-}")
$(split_args_by_lf "${BWRAP_ARGS:-}")"
paths_from_args=$(
    set -f; IFS='
'
    # shellcheck disable=SC2086
    set -- $_USER_ARGS
    while [ $# -gt 0 ]; do
        case "$1" in --*bind*) echo "$2" ;; esac
        shift
    done
)
# shellcheck disable=SC2086
set -- $_USER_ARGS "${0%/*}/$EXECUTABLE" "$@"
unset IFS

# Make private temp dir for use as TMPDIR
uid="$(id -u)"
tmpdir="$(mktemp -d -t ".sandbox-venv.$uid.$$.XXXXXX")"
cleanup_temp () { [ -z "$(find "$tmpdir" -type f -print -quit)" ] && rm -r "$tmpdir"; }
trap cleanup_temp EXIT

# Support for Open URLs / XDG Desktop Portal in wrapped applications
if command_exists xdg-dbus-proxy; then
    dbus_proxy_path="$tmpdir/dbus-proxy"
    fifo_path="${dbus_proxy_path}.sync"
    mkfifo "$fifo_path"

    xdg-dbus-proxy --fd=8 8>"$fifo_path" \
        "${DBUS_SESSION_BUS_ADDRESS:-unix:path=${XDG_RUNTIME_DIR:-/run/user/$uid}/bus}" \
        "$dbus_proxy_path" --filter --talk=org.freedesktop.portal.* \
        &

    # Unblock FIFO and wait for xdg-dbus-proxy to touch $dbus_proxy_path
    exec 7<"$fifo_path" && rm "$fifo_path" && sleep .1 && test -e "$dbus_proxy_path"

    add_dbus_send () {
        for exe in dbus-send gdbus busctl; do
            if command_exists "$exe"; then
                executables="$executables
$(command -v "$exe")"
                return 0
            fi
        done
        return 1
    }
    add_dbus_send || warn 'Need one of dbus-send (from package dbus-bin) / gdbus (libglib*-bin) / busctl (systemd) to use XDG Desktop Portal'

    exec 9<<EOF
#!/bin/sh
set -eu
address="unix:path=$dbus_proxy_path"
pth='/org/freedesktop/portal/desktop'
service='org.freedesktop.portal.Desktop'
interface='org.freedesktop.portal.OpenURI'
method='OpenURI'
dbus-send --bus="\$address" --type method_call --dest=\$service \$pth \$interface.\$method \
    string: string:"\$1" dict:string:variant: \
||
gdbus call --address "\$address" --dest \$service --object-path \$pth --method \$interface.\$method \
    '' "\$1" '{}' >/dev/null \
||
busctl --verbose --address "\$address" call \$service \$pth \$interface \$method \
    'ssa{sv}' '' "\$1" 0
EOF
    exec 6<<EOF
[Instance]
flatpak-version=9000
EOF
    xdg_open='/usr/bin/xdg-open'
    # Extra bwrap args
    # FIXME: Implementation is BUGGY. Even as appropriate mounts are bound,
    #   a full working XDG Portal (e.g. a working file chooser FUSE mount)
    #   was so far in testing of some PyQt5 app not achieved.
    #   D-Bus communication does happen, as observed with:
    #
    #       busctl --user monitor org.freedesktop.portal.Documents org.freedesktop.portal.Desktop org.freedesktop.impl.portal.desktop.gtk
    #
    #   A LLM suggests it may have something to do with the process PID being
    #   that of the xdg-dbus-proxy, run by this user outside the sandbox. :shrug:
    set -- --block-fd 7 --sync-fd 7 \
        --setenv DBUS_SESSION_BUS_ADDRESS "unix:path=$dbus_proxy_path" \
        --perms 0555 --ro-bind-data 9 "$xdg_open" \
        --symlink "$xdg_open" "/usr/bin/chromium" \
        --symlink "$xdg_open" "/usr/bin/x-www-browser" \
        --ro-bind-data 6 "/.flatpak-info" \
        --bind "${XDG_RUNTIME_DIR:-/run/user/$uid}/doc" "${XDG_RUNTIME_DIR:-/run/user/$uid}/doc" \
        --setenv container 'sandbox-venv' \
        "$@"
else
    warn "Can't mock xdg-open or use XDG Desktop Portal: xdg-dbus-proxy not available."
    set -- --dir "/run/user/$uid" "$@"
fi

# Quiet very verbose, iterative args-constructing parts that follow
case $- in *x*) xtrace=-x ;; *) xtrace=+x ;; esac; set +x

# Collect binaries' lib dependencies
cache_file="$venv/cache/sandbox-venv.cache"
if [ -s "$cache_file" ] && [ ! "$0" -nt "$cache_file" ] && [ ! "${proj_dir}/.env" -nt "$cache_file" ]; then
    collect="$(cat "$cache_file")"
else
    for exe in readelf ldd; do command_exists "$exe" || { warn "Missing executable: $exe"; exit 1; }; done
    lib_deps () {
        readelf -l "$1" >/dev/null 2>&1 || return 0  # Not a binary file
        readelf -l "$1" | awk '/interpreter/ {print $NF}' | tr -d '[]'
        ldd "$1" | awk '/=>/ { print $3 }' | grep -F -v "$venv" | grep -E '^/' || true
    }
    collect="$executables"
    for exe in $executables; do
        collect="$collect
            $(lib_deps "$exe")"
    done
    root_so_lib_dirs="
        /usr/lib/python3*/lib-dynload
        /usr/lib64/python3*/lib-dynload"
    # XXX: If some `git` tools are failing, add $(find /usr/lib/git-core -type f)
    for exe in $(find "$venv/lib" $root_so_lib_dirs -name '*.so' 2>/dev/null || true); do
        collect="$collect
            $(lib_deps "$exe")"
    done

    # Filter collect, warn on non-existant paths, unique sort, cull.
    # Use separate for-loop to expand globstar.
    prev="sandbox@"
    collect="
        $collect
        $ro_bind_extra
        $seccomp_libs
        $git_libs
        $py_libs"
    collect="$(
        for path in $collect; do
            [ -e "$path" ] ||
                # Don't warn for globstar paths as they are allowed to not match
                case "$path" in *\**) continue ;; *) warn "Warning: missing $path"; continue ;; esac
            echo "$path"
        done |
        sort -u |
        # If collected paths contain /foo// and /foo/bar,
        # keep only /foo since it covers both
        while IFS= read -r path; do
            case $path in "$prev"/*) continue;; esac
            echo "$path"; prev="$path"
        done)"
    mkdir -p "$venv/cache"
    printf '%s\n' "$collect" > "$cache_file"
fi

# If user had already --bind /usr, avoid our /usr/lib
collect="$(printf '%s\n' "$collect" |
    while IFS= read -r path; do
        IFS='
        '; for prefix in $paths_from_args; do
            case "$path" in "${prefix%/}"/*) continue 2;; esac
        done
        echo "$path"
    done)"
for path in $collect; do set -- --ro-bind "$path" "$path" "$@"; done

# RW bind $HOME and cache dirs for downloads etc.
home="${HOME:-"/home/$USER"}"
pip_cache="$home/${XDG_CACHE_HOME:-.cache}/pip"
mkdir -p "$venv/home" "$venv/cache" "$pip_cache"
[ ! "${SANDBOX_USE_PIP_CACHE-}" ] || {
    mkdir -p "$venv/cache/pip" &&
        echo "This dir is an artefact of Bubblewrap bind mounting. Real pip cache is in \$HOME/.cache/pip" \
        > "$venv/cache/pip/note.txt"
    set -- --bind "$pip_cache" "$home/.cache/pip" "$@"
}
set -- --bind "$venv/cache" "$home/.cache" "$@"
# RW-bind project dir (dir that contains .venv)
# but RO-bind some dirs like .venv and git
ro_bind_pwd_extra="
    ${venv##*/}
    .git"
for path in $ro_bind_pwd_extra; do
    [ ! -e "$proj_dir/$path" ] || set -- --ro-bind "$proj_dir/$path" "$proj_dir/$path" "$@"
done
# Lastly ... (this arg will appear first)
set -- --bind "$venv/home" "$home" --bind "$proj_dir" "$proj_dir" "$@"

# Pass our own redacted copy of env
# Expose all vars passed exclusively to this process (i.e. not its parent)
IFS=$(printf '\037')
for var in $(env -0 |
        grep -Ez -e '^('\
'USER|LOGNAME|UID|PATH|TERM|HOSTNAME|'\
'LANGUAGE|LANG|LC_.*?|TZ|'\
'https?_proxy|HTTPS?_PROXY|'\
'CC|CFLAGS|CXXFLAGS|CPPFLAGS|LDFLAGS|LDLIBS|MAKEFLAGS)=' \
                 -e "^($(env -0 |
                         cut -z -d= -f1 |
                         grep -Ezv "^($(cut -z -d= -f1 </proc/$PPID/environ |
                                        paste -z -s -d '|'))$" |
                         paste -z -s -d '|'))=" |
        grep -Ezv -e '^(_|LS_COLORS|PS1)=' |
        tr '\0' '\037'); do
    set -- --setenv "${var%%=*}" "${var#*=}" "$@"
done
unset IFS

set $xtrace

cwd="$(pwd)"

warn "exec bwrap [...] $formatted_cmdline"

[ ! "${VERBOSE:-${verbose:-}}" ] || set -x

# shellcheck disable=SC2086
bwrap \
    --dir /tmp \
    --dir "$cwd" \
    --bind "$tmpdir" "$tmpdir" \
    --chdir "$cwd" \
    --proc /proc \
    --dev /dev \
    --clearenv \
    --unshare-all \
    --share-net \
    --new-session \
    --die-with-parent \
    --setenv PS1 '\u @ \h \$ ' \
    --setenv HOME "$home" \
    --setenv USER "user" \
    --setenv VIRTUAL_ENV "$venv" \
    --setenv PYTHONPATH "$venv/sandbox:${PYTHONPATH-}" \
    --setenv TMPDIR "$tmpdir" \
    --bind-data 5 /etc/passwd \
    --bind-data 4 /etc/group \
    "$@" \
    5<<EOF 4<<EOF2
$(getent passwd "$uid" nobody)
EOF
$(getent group "$(id -g)" nogroup adm sudo audio dip video plugdev staff users netdev scanner bluetooth lpadmin bumblebee)
EOF2

exec 7<&- && wait ${!-}  # Close FD 7, permitting xdg-dbus-proxy to exit


# CUT HERE ------------------- Appendix 3: sandbox-venv sitecustomize.py script
#!/usr/bin/python3
"""
Importing this module inits seccomp/pyseccomp, restricting allowed syscalls to those
listed in SANDBOX_SECCOMP_ALLOW environment variable (or, by default, the list below).
The module is imported automatically upon startup when on PYTHONPATH.

https://docs.python.org/3/library/site.html#module-sitecustomize
"""
import os
import re
import sys

# XXX: You can debug this list (e.g. update missing items) by
#  looking for EPERM in `strace -f` output.
ALLOW_SYSCALLS = [
    # Process & signals
    "clone", "clone3", "fork", "vfork", "execve", "exit", "exit_group",
    "kill", "tgkill", "tkill", "wait4", "getpid", "getppid", "gettid",
    "prctl", "arch_prctl", "getpgrp",
    "pidfd_open", "pidfd_send_signal",
    "sigaction", "sigreturn",
    "rt_sigaction", "rt_sigreturn",
    "rt_sigprocmask", "rt_sigpending", "rt_sigsuspend",
    "sigaltstack", "rseq", "process_madvise",

    # File I/O
    "open", "openat", "close", "close_range", "read", "write",
    "name_to_handle_at",
    "pread64", "pwrite64", "preadv", "pwritev", "preadv2", "pwritev2",
    "lseek",
    "stat", "statx", "fstat", "lstat", "fstatat64", "newfstatat",
    "stat64", "lstat64", "fstat64", "fadvise64",
    "faccessat2", "getdents", "getdents64", "access",
    "unlink", "unlinkat", "mkdir", "mkdirat", "rmdir",
    "rename", "renameat", "renameat2",
    "readlink", "readlinkat", "symlink", "symlinkat", "link", "linkat",
    "truncate", "ftruncate", "utime", "utimes", "futimesat", "utimensat",
    "chown", "fchown", "lchown", "fchmod", "fchmodat", "chmod", "mknod", "mknodat",
    "getxattr", "setxattr", "listxattr", "removexattr",

    # fd ops
    "dup", "dup2", "dup3", "pipe", "pipe2",
    "fcntl", "flock", "fsync", "fdatasync",
    "readahead",
    "splice", "tee", "vmsplice",

    # mmap / mem / threads
    "brk", "mmap", "mmap2", "munmap", "mremap", "mprotect", "madvise", "mincore",
    "futex", "futex_time64", "futex_waitv", "set_tid_address", "set_robust_list", "get_robust_list",
    "sched_yield", "sched_getaffinity",
    "mlock", "munlock", "mlockall", "munlockall",
    "get_mempolicy", "set_mempolicy", "mbind", "migrate_pages", "move_pages",
    "membarrier",

    # Time / clocks
    "nanosleep", "clock_gettime", "clock_getres", "gettimeofday", "time",
    "clock_nanosleep", "clock_gettime64",
    "timer_create", "timer_settime", "timer_gettime", "timer_delete",
    "setitimer", "getitimer", "times",
    "timerfd_create", "timerfd_settime", "timerfd_gettime",

    # Networking
    "socket", "socketpair", "socketcall", "bind", "listen",
    "accept", "accept4", "connect",
    "getsockname", "getpeername",
    "sendto", "recvfrom", "sendmsg", "recvmsg", "shutdown",
    "setsockopt", "getsockopt",
    "recvmmsg", "sendmmsg",
    "sendfile", "sendfile64",

    # epoll/poll/select
    "epoll_create", "epoll_create1", "epoll_ctl", "epoll_wait",
    "epoll_pwait", "epoll_pwait2",
    "poll", "ppoll", "ppoll_time64", "select", "pselect6",
    "eventfd", "eventfd2",

    # Descriptors / metadata
    "ioctl", "readv", "writev",
    "getcwd", "chdir", "fchdir",
    "statfs", "fstatfs", "statfs64", "fstatfs64",

    # UIDs/GIDs (read + drop privileges)
    "getuid", "geteuid", "getgid", "getegid", "getgroups",
    "getresuid", "getresgid", "setresuid", "setresgid", "setreuid", "setregid",
    "setuid", "setgid",

    # Limits / info
    "getrlimit", "setrlimit", "prlimit64", "uname", "sysinfo", "getrusage", "umask",

    # Random
    "getrandom",

    # Misc
    "seccomp", "capget",
    "shmget", "shmat", "shmdt", "shmctl",
]


try:
    allow_syscalls = re.findall(r'\w+', os.environ['SANDBOX_SECCOMP_ALLOW'])
except KeyError:
    allow_syscalls = ALLOW_SYSCALLS

if allow_syscalls:
    try:
        import seccomp
    except ImportError:
        try:
            import pyseccomp as seccomp
        except ImportError:
            seccomp = None
            if sys.platform.startswith('linux'):
                print("sandbox-venv/seccomp: Python package 'seccomp' (or 'pyseccomp') "
                      "not available. If you want seccomp support, apt install python3-seccomp "
                      "(requires venv created with --system-site-packages) "
                      "or pip install pyseccomp.", file=sys.stderr)
    if seccomp:
        print(f'sandbox-venv/seccomp: allowing {len(allow_syscalls)} syscalls', file=sys.stderr)
        default_action = seccomp.ERRNO(seccomp.errno.EPERM)  # EPERM, Operation not permitted
        filter = seccomp.SyscallFilter(default_action)
        for syscall in allow_syscalls:
            # print(syscall, file=sys.stderr)
            filter.add_rule(seccomp.ALLOW, syscall)
        filter.load()
